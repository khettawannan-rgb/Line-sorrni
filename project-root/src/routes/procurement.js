// project-root/src/routes/procurement.js
import express from 'express';
import multer from 'multer';
import dayjs from 'dayjs';

import {
  listRequisitions,
  createRequisition,
  submitForApproval,
  updateRequisitionStatus,
  listPurchaseOrders,
  createPurchaseOrder,
  updatePurchaseOrderStatus,
  listVendors,
  createVendor,
  updateVendor,
  getVendorById,
  ensureSeedVendors,
  getLowStockItems,
  generateSnapshot,
  listStockItems,
  PR_STATUSES,
  PO_STATUSES,
  STATUS_LABELS,
  getRequisitionById,
  getPurchaseOrderById,
  generatePurchaseOrderPdf,
  markPdfGenerated,
  markEmailSent,
  sendPurchaseOrderEmail,
  notifyPoStatus,
} from '../services/procurement/index.js';
import { ensureStorageDirectories, saveAttachment } from '../services/procurement/storageService.js';

const router = express.Router();
const upload = multer({ storage: multer.memoryStorage() });
const DEFAULT_COMPANY_ID = process.env.DEFAULT_COMPANY_ID || null;

ensureStorageDirectories();

router.use((req, res, next) => {
  res.locals.procurementNav = true;
  next();
});

function requireAuth(req, res, next) {
  if (req.session?.user) return next();
  return res.redirect('/admin/login');
}

function actorName(req) {
  return req.session?.user?.username || 'system';
}

function parseItems(body = {}) {
  const names = Array.isArray(body.itemName) ? body.itemName : [body.itemName];
  const qtys = Array.isArray(body.quantity) ? body.quantity : [body.quantity];
  const units = Array.isArray(body.unit) ? body.unit : [body.unit];
  const notes = Array.isArray(body.itemNote) ? body.itemNote : [body.itemNote];
  const prices = Array.isArray(body.unitPrice) ? body.unitPrice : [body.unitPrice];

  return names
    .map((name, idx) => ({
      itemName: name,
      quantity: Number(qtys[idx] || 0),
      unit: units[idx] || 'ตัน',
      note: notes[idx] || '',
      unitPrice: prices[idx] !== undefined && prices[idx] !== '' ? Number(prices[idx]) : undefined,
    }))
    .filter((item) => item.itemName && item.quantity > 0);
}

function extractAttachments(files = []) {
  return files.map((file) => {
    const stored = saveAttachment(file.buffer, file.originalname);
    return {
      filename: stored.filename,
      originalName: file.originalname,
      mimeType: file.mimetype,
      size: file.size,
      url: stored.url,
    };
  });
}

router.get('/pr', requireAuth, async (req, res, next) => {
  try {
    res.locals.active = 'procurement-pr';
    await ensureSeedVendors();
    const [prs, vendors, lowStock, stockItems] = await Promise.all([
      listRequisitions({}, { limit: 25 }),
      listVendors({ activeOnly: true }),
      DEFAULT_COMPANY_ID ? getLowStockItems(DEFAULT_COMPANY_ID) : [],
      DEFAULT_COMPANY_ID ? listStockItems({ companyId: DEFAULT_COMPANY_ID }) : [],
    ]);

    res.render('procurement/pr_list', {
      title: 'Purchase Requisitions',
      prs,
      vendors,
      lowStock,
      stockItems,
      PR_STATUSES,
      STATUS_LABELS,
      defaultCompanyId: DEFAULT_COMPANY_ID,
      dayjs,
    });
  } catch (err) {
    next(err);
  }
});

router.post(
  '/pr',
  requireAuth,
  upload.array('attachments', 5),
  async (req, res, next) => {
    try {
      const items = parseItems(req.body);
      if (!items.length) {
        return res.redirect('/admin/pr?error=no-item');
      }

      const attachments = extractAttachments(req.files || []);
      await createRequisition(
        {
          companyId: req.body.companyId || DEFAULT_COMPANY_ID,
          requestedBy: req.body.requestedBy || actorName(req),
          note: req.body.note || '',
          items,
          attachments,
          source: req.body.source || (req.body.autoGenerated ? 'auto-low-stock' : 'manual'),
          autoGenerated: !!req.body.autoGenerated,
        },
        actorName(req)
      );

      return res.redirect('/admin/pr?created=1');
    } catch (err) {
      next(err);
    }
  }
);

router.post('/pr/:id/submit', requireAuth, async (req, res, next) => {
  try {
    await submitForApproval(req.params.id, actorName(req));
    res.redirect('/admin/pr?submitted=1');
  } catch (err) {
    next(err);
  }
});

router.post('/pr/:id/status', requireAuth, async (req, res, next) => {
  try {
    const status = req.body.status;
    await updateRequisitionStatus(req.params.id, status, actorName(req), req.body.remark || '');
    res.redirect('/admin/pr?status=updated');
  } catch (err) {
    next(err);
  }
});

router.get('/po', requireAuth, async (req, res, next) => {
  try {
    res.locals.active = 'procurement-po';
    const [pos, vendors, prs] = await Promise.all([
      listPurchaseOrders({}, { limit: 25 }),
      listVendors({ activeOnly: true }),
      listRequisitions({ status: PR_STATUSES.APPROVED }),
    ]);

    res.render('procurement/po_list', {
      title: 'Purchase Orders',
      pos,
      vendors,
      prs,
      PO_STATUSES,
      STATUS_LABELS,
      dayjs,
    });
  } catch (err) {
    next(err);
  }
});

router.post('/po', requireAuth, async (req, res, next) => {
  try {
    const items = parseItems(req.body);
    if (!items.length) {
      return res.redirect('/admin/po?error=no-item');
    }

    const actor = actorName(req);
    const created = await createPurchaseOrder(
      {
        prId: req.body.prId || null,
        vendorId: req.body.vendorId,
        companyId: req.body.companyId || DEFAULT_COMPANY_ID,
        items,
        expectedDeliveryDate: req.body.expectedDeliveryDate
          ? new Date(req.body.expectedDeliveryDate)
          : null,
        paymentTerms: req.body.paymentTerms || 'Credit 30 days',
        remarks: req.body.note || '',
        currency: req.body.currency || 'THB',
      },
      actor
    );

    try {
      const [po, vendor] = await Promise.all([
        getPurchaseOrderById(created._id),
        getVendorById(req.body.vendorId),
      ]);
      if (po && vendor) {
        const pdf = await generatePurchaseOrderPdf(po, vendor);
        await markPdfGenerated(po._id, pdf.pdfPath, pdf.pdfUrl);
        const emailInfo = await sendPurchaseOrderEmail({
          po: { ...po, pdfUrl: pdf.pdfUrl },
          vendor,
          pdfPath: pdf.pdfPath,
          pdfUrl: pdf.pdfUrl,
        });
        await markEmailSent(po._id, {
          provider: emailInfo?.envelope ? 'nodemailer' : 'stream',
          messageId: emailInfo?.messageId || '',
          actor,
        });
        await notifyPoStatus({ ...po, pdfUrl: pdf.pdfUrl });
      }
    } catch (automationErr) {
      console.error('[PROCUREMENT] post-create automation failed:', automationErr);
    }

    res.redirect('/admin/po?created=1');
  } catch (err) {
    next(err);
  }
});

router.post('/po/:id/status', requireAuth, async (req, res, next) => {
  try {
    const status = req.body.status;
    await updatePurchaseOrderStatus(req.params.id, status, actorName(req), req.body.remark || '');
    try {
      const po = await getPurchaseOrderById(req.params.id);
      await notifyPoStatus(po);
    } catch (notifyErr) {
      console.error('[PROCUREMENT] notify status change failed:', notifyErr);
    }
    res.redirect('/admin/po?status=updated');
  } catch (err) {
    next(err);
  }
});

router.get('/vendors', requireAuth, async (req, res, next) => {
  try {
    res.locals.active = 'procurement-vendors';
    const vendors = await listVendors({});
    res.render('procurement/vendor_list', {
      title: 'Vendors',
      vendors,
    });
  } catch (err) {
    next(err);
  }
});

router.post('/vendors', requireAuth, async (req, res, next) => {
  try {
    const payload = {
      name: req.body.name,
      email: req.body.email,
      phone: req.body.phone,
      address: req.body.address,
      productCategories: (req.body.productCategories || '')
        .split(',')
        .map((s) => s.trim())
        .filter(Boolean),
      contact: {
        name: req.body.contactName,
        email: req.body.contactEmail,
        phone: req.body.contactPhone,
      },
      notes: req.body.notes || '',
    };
    await createVendor(payload, actorName(req));
    res.redirect('/admin/vendors?created=1');
  } catch (err) {
    next(err);
  }
});

router.post('/vendors/:id', requireAuth, async (req, res, next) => {
  try {
    const payload = {
      name: req.body.name,
      email: req.body.email,
      phone: req.body.phone,
      address: req.body.address,
      productCategories: (req.body.productCategories || '')
        .split(',')
        .map((s) => s.trim())
        .filter(Boolean),
      notes: req.body.notes || '',
    };
    await updateVendor(req.params.id, payload, actorName(req));
    res.redirect('/admin/vendors?saved=1');
  } catch (err) {
    next(err);
  }
});

router.get('/settings/procurement', requireAuth, async (req, res, next) => {
  try {
    res.locals.active = 'procurement-settings';
    const config = {
      defaultCompanyId: DEFAULT_COMPANY_ID,
      emailProvider: process.env.PROCUREMENT_EMAIL_PROVIDER || 'nodemailer',
      lineChannel: process.env.PROCUREMENT_LINE_CHANNEL || 'default',
      notifyRoles: (process.env.PROCUREMENT_NOTIFY_ROLES || 'procurement,warehouse').split(','),
      safetyStockDays: Number(process.env.PROCUREMENT_SAFETY_DAYS || 3),
    };

    res.render('procurement/settings', {
      title: 'Procurement Settings',
      config,
      lastSnapshotAt: null,
    });
  } catch (err) {
    next(err);
  }
});

router.post('/settings/procurement/snapshot', requireAuth, async (req, res, next) => {
  try {
    if (!DEFAULT_COMPANY_ID) {
      return res.redirect('/admin/settings/procurement?error=no-company');
    }

    await generateSnapshot(DEFAULT_COMPANY_ID, {
      safetyStockDays: req.body.safetyStockDays || 3,
    });
    res.redirect('/admin/settings/procurement?snapshot=1');
  } catch (err) {
    next(err);
  }
});

router.get('/pr/:id/json', requireAuth, async (req, res, next) => {
  try {
    const pr = await getRequisitionById(req.params.id);
    if (!pr) return res.status(404).json({ error: 'PR not found' });
    res.json({ data: pr });
  } catch (err) {
    next(err);
  }
});

router.get('/po/:id/json', requireAuth, async (req, res, next) => {
  try {
    const po = await getPurchaseOrderById(req.params.id);
    if (!po) return res.status(404).json({ error: 'PO not found' });
    res.json({ data: po });
  } catch (err) {
    next(err);
  }
});

export default router;
